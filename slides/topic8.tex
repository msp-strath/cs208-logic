% -*- TeX-engine: xetex -*-

\documentclass[xetex,aspectratio=169,14pt,hyperref={pdfpagelabels=true,pdflang={en-GB}}]{beamer}

\input{macros}

\weektitle{8}{Semantics of Predicate Logic}

\begin{document}

\frame{\titlepage}

\weeksection{Models}

\begin{frame}
  {So far: Syntax and Proof}

  \begin{enumerate}
  \item Topic 3: The syntax of predicate logic \\
    \textcolor{black!60}{What sequences of symbols are well formed?}
  \item Topic 4: Proofs for predicate logic \\
    \textcolor{black!60}{When are formulas consequences of other formulas?}
  \item Topics 5-7: Hoare Logic \\
    \textcolor{black!60}{An Application of Predicate Logic}
  \end{enumerate}
\end{frame}

\begin{frame}
  {Missing so far: \emph{semantics}}
  \begin{enumerate}
  \item For Propositional Logic, we defined the \emph{semantics}
    (``meaning'') of a formula $P$:
    \begin{itemize}
    \item For every \emph{valuation} $v$,\\
      the formula $P$ is assigned a meaning $\sem{P}~v$ which is either $\true$ or $\false$.
    \end{itemize}
  \item This definition enabled us to give a definition of
    \emph{entailment}:
    \begin{displaymath}
      P_1, \dots, P_n \models Q
    \end{displaymath}
    which defines consequence without using proofs.
  \end{enumerate}
\end{frame}

\begin{frame}
  {Semantics for Predicate Logic}

  The plan:
  \begin{enumerate}
  \item Fix \emph{vocabularies} $\mathcal{V}$
  \item Define \emph{models} $\mathcal{M}$ for $\mathcal{V}$
  \item Interpret \emph{formulas} $P$ using vocabulary $\mathcal{V}$ in models $\mathcal{M}$
  \item Find uses for models (databases, generation, ...)
  \item ...
  \item Profit!
  \end{enumerate}
\end{frame}

\begin{frame}
  {Fixing a Vocabulary}

  The function symbols we will use, and their \emph{arities}
  (number of arguments):
  \begin{displaymath}
    \begin{array}{l|l}
      \textrm{Function name(s)}&\textrm{Arity}\\
      \hline
      \mathrm{socrates} & 0 \\
      \mathrm{dayAfter} & 1 \\
      +, -              & 2\\
    \end{array}
  \end{displaymath}
  We write ``$\mathrm{func}/n$'' for function symbol $\mathrm{func}$
  with arity $n$
\end{frame}

\begin{frame}
  {Fixing a Vocabulary}

  The predicates / relation symbols we will use, and their arities:
  \begin{displaymath}
    \begin{array}{l|l}
      \textrm{Predicate name(s)}&\textrm{Arity} \\
      \hline
      \mathrm{human}, \mathrm{mortal} & 1 \\
      <, \leq, =                      & 2 \\
      \mathrm{between}                & 3
    \end{array}
  \end{displaymath}
  We write ``$\mathrm{pred}/n$'' for predicate symbol
  $\mathrm{pred}$ with arity $n$
\end{frame}

\begin{frame}
  \sechead{A simplification}

  \bigskip

  To keep things simple, I'm going to assume that we don't have any
  function symbols in our vocabulary.
\end{frame}

\begin{frame}
  \sechead{Example: Orderings}
  \begin{itemize}
  \item $\mathord{\leq}/2$ \quad \textcolor{black!60}{``less than''}
  \end{itemize}

  \bigskip

  \sechead{Example: Places}
  \begin{itemize}
  \item $\mathrm{city}/1$ \quad \textcolor{black!60}{``is a city''}
  \item $\mathrm{within}/2$ \quad \textcolor{black!60}{``is within''}
  \item $\mathrm{country}/1$ \quad \textcolor{black!60}{``is a country''}
  \end{itemize}

  \bigskip

  \sechead{Example: Forestry and Birdwatching}
  \begin{itemize}
  \item $\mathrm{tree}/1$ \quad \textcolor{black!60}{``is a tree''}
  \item $\mathrm{green}/1$ \quad \textcolor{black!60}{``is green''}
  \item $\mathrm{bird}/1$ \quad \textcolor{black!60}{``is a bird''}
  \item $\mathrm{satIn}/2$ \quad \textcolor{black!60}{``has sat in''}
  \end{itemize}
\end{frame}

\begin{frame}
  {Models}

  With a fixed vocabulary, a \emph{model} $\mathcal{M}$ is:
  \begin{enumerate}
  \item A \emph{universe} $U$, which is a set of individuals:
    \begin{displaymath}
      U = \{ 1, 2, \mathsf{socrates}, \mathsf{hypatia}, \mathsf{noether}, \mathsf{alexandria}, \mathsf{glasgow}, \dots \}
    \end{displaymath}
  \item For each predicate $\mathrm{pred}/n$, an $n$-ary
    relation on the set $U$.
  \end{enumerate}
\end{frame}

\begin{frame}
  {Relations}

  Several ways of understanding what a relation is:
  \begin{enumerate}
  \item For every $n$ elements from $U$, the interpretation of
    $\mathrm{pred}/n$ assigns the value $\true$ or $\false$.\\
    \bigskip
  \item The interpretation of $\mathrm{pred}/n$ is a (possibly
    infinite) table of elements of $U$ with $n$ columns.
    \bigskip
  \item The interpretation of $\mathrm{pred}/n$ is a subset of the
    $n$-fold \emph{cartesian product}
    $\underbrace{U \times \dots \times U}_{n~\mathrm{times}}$.\\
  \end{enumerate}
\end{frame}

\begin{frame}
  \sechead{Example: Places, interpretation 1}
  \begin{displaymath}
    \begin{array}{l@{\hspace{0.3em}}c@{\hspace{0.3em}}l}
      U &=& \{ \mathsf{aberdeen}, \mathsf{edinburgh}, \mathsf{glasgow}, \mathsf{scotland},  \mathsf{birmingham}, \mathsf{england} \}\\
      \mathsf{city} &=& \{ \mathsf{aberdeen}, \mathsf{edinburgh}, \mathsf{glasgow}, \mathsf{birmingham} \}\\
      \mathsf{country} &=& \{ \mathsf{england}, \mathsf{scotland} \} \\
      \mathsf{within} &=& \{
                          \begin{array}[t]{@{}l}
                            (\mathsf{aberdeen}, \mathsf{scotland}), (\mathsf{edinburgh}, \mathsf{scotland}), \\
                            (\mathsf{glasgow}, \mathsf{scotland}), (\mathsf{birmingham}, \mathsf{england}) \}
                          \end{array}
    \end{array}
  \end{displaymath}
\end{frame}

\begin{frame}
  \sechead{Example: Places, interpretation 1}

  \bigskip

  \begin{displaymath}
    U = \{ \mathsf{aberdeen}, \mathsf{edinburgh}, \mathsf{glasgow}, \mathsf{scotland},  \mathsf{birmingham}, \mathsf{england} \}
  \end{displaymath}
  As tables:
  \begin{mathpar}
    \begin{array}{|c|}
      \hline
      \mathrm{city} \\
      \hline
      \mathsf{aberdeen} \\
      \mathsf{edinburgh} \\
      \mathsf{glasgow} \\
      \mathsf{birmingham}\\
      \hline
    \end{array}

    \begin{array}{|c|}
      \hline
      \mathrm{country} \\
      \hline
      \mathsf{england} \\
      \mathsf{scotland} \\
      \hline
    \end{array}

    \begin{array}{|cc|}
      \hline
      \multicolumn{2}{|c|}{\mathrm{within}}\\
      \hline
      \mathsf{aberdeen} & \mathsf{scotland} \\
      \mathsf{edinburgh} & \mathsf{scotland} \\
      \mathsf{glasgow} & \mathsf{scotland} \\
      \mathsf{birmingham} & \mathsf{england} \\
      \hline
    \end{array}
  \end{mathpar}
\end{frame}

\begin{frame}
  \sechead{Example: Places, interpretation 2}
  \begin{displaymath}
    \begin{array}{lcl}
      U &=& \{ \mathsf{loopland} \} \\
      \mathsf{city} &=& \{ \mathsf{loopland} \} \\
      \mathsf{country} &=& \{ \mathsf{loopland} \} \\
      \mathsf{within} &=& \{ (\textsf{loopland}, \textsf{loopland}) \}
    \end{array}
  \end{displaymath}

  \pause

  The names are only there to separate the predicates. Models do not
  have to match our intuition for the names.
\end{frame}

\begin{frame}
  \sechead{Example: Interpreting ordering with natural numbers}
  \begin{enumerate}
  \item $U = \{ 0, 1, 2, \dots \} = \mathbb{N}$ (all positive whole numbers)
  \item The interpretation of $\mathord{\leq}/2$ is all pairs $(x, y)$ such that $x \leq y$
  \end{enumerate}
\end{frame}

\begin{frame}
  \sechead{Example: Interpreting ordering with rational numbers}
  \begin{enumerate}
  \item $U = \{ 0, -1, 1, -\frac{1}{2}, \frac{1}{2}, -2, 2, \dots \} = \mathbb{Q}$
  \item The interpretation of $\mathord{\leq}/2$ is all pairs $(x, y)$ such that $x \leq y$
  \end{enumerate}
\end{frame}

\begin{frame}
  \sechead{Example: Interpreting ordering with a small set}
  \begin{enumerate}
  \item $U = \{ \mathsf{a}, \mathsf{b}, \mathsf{c} \}$
  \item The interpretation of $\mathord{\leq}/2$ is the set:
    \begin{displaymath}
      \{ (\mathsf{a},\mathsf{b}), (\mathsf{a},\mathsf{c}) \}
    \end{displaymath}
    Note! not necessarily what we might think of as $\leq$! Need to
    add axioms.
  \end{enumerate}
\end{frame}

\begin{frame}
  {Important Points}


  Every model $\mathcal{M}$ has
  \begin{enumerate}
  \item a universe; and
  \item a relation for each predicate symbol $\mathrm{pred}/n$,
  \end{enumerate}
  but the domain can be empty, or the predicate symbols' interpretations may be empty!

  \bigskip

  The model needn't match our intuition about the symbols!
  \begin{itemize}
  \item Will assume formulas that will restrict the possible models.
  \end{itemize}
\end{frame}

\begin{frame}
  {Relationship to Valuations}

  \bigskip

  If all our predicate symbols have arity $0$ (take no arguments),
  then a model consists of:
  \begin{enumerate}
  \item A universe $U$; and
  \item An assignment of $\true$ or $\false$ to each predicate symbol
    $\mathrm{pred}/0$.
  \end{enumerate}

  \bigskip

  Apart from the universe, this is the same as a \emph{valuation} in
  Propositional Logic (Topic 0).
\end{frame}

\begin{frame}
  {Summary}

  We interpret Predicate Logic formulas in a \emph{model} $\mathcal{M}$.
  \begin{itemize}
  \item A universe $U$ -- the set of all ``things''.
  \item A relation between elements of $U$ for every predicate.
  \end{itemize}

  \bigskip

  Useful intuition: models are (possibly infinite) databases.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\weeksection{Interpreting Formulas}

\begin{frame}
  {Meaning of free variables}

  Assume a vocabulary $\mathcal{V}$ and model $\mathcal{M}$ are fixed.

  \bigskip

  Consider the formula:
  \begin{displaymath}
    \mathrm{city}(x) \land \mathrm{within}(x,y)
  \end{displaymath}
  we can't give it a truth value until we know what $x$ and $y$ mean.
\end{frame}

\begin{frame}
  {Cities Model}
  \begin{displaymath}
    U = \{ \mathsf{aberdeen}, \mathsf{edinburgh}, \mathsf{glasgow}, \mathsf{scotland},  \mathsf{birmingham}, \mathsf{england} \}
  \end{displaymath}
  As tables:
  \begin{mathpar}
    \begin{array}{|c|}
      \hline
      \mathrm{city} \\
      \hline
      \mathsf{aberdeen} \\
      \mathsf{edinburgh} \\
      \mathsf{glasgow} \\
      \mathsf{birmingham}\\
      \hline
    \end{array}

    \begin{array}{|c|}
      \hline
      \mathrm{country} \\
      \hline
      \mathsf{england} \\
      \mathsf{scotland} \\
      \hline
    \end{array}

    \begin{array}{|cc|}
      \hline
      \multicolumn{2}{|c|}{\mathrm{within}}\\
      \hline
      \mathsf{aberdeen} & \mathsf{scotland} \\
      \mathsf{edinburgh} & \mathsf{scotland} \\
      \mathsf{glasgow} & \mathsf{scotland} \\
      \mathsf{birmingham} & \mathsf{england} \\
      \hline
    \end{array}
  \end{mathpar}
\end{frame}

\begin{frame}
  {Meaning of free variables}

  With the cities model, if we set:
  \begin{mathpar}
    x = \mathsf{glasgow}

    y = \mathsf{scotland}
  \end{mathpar}
  then $\mathrm{city}(x) \land \mathrm{within}(x,y)$ should be assigned the truth value $\true$.

  \bigskip
  \pause

  If we set:
  \begin{mathpar}
    x = \mathsf{scotland}

    y = \mathsf{edinburgh}
  \end{mathpar}
  then $\mathrm{city}(x) \land \mathrm{within}(x,y)$ should be assigned the truth value $\false$.
\end{frame}

\begin{frame}
  {Interpreting Formulas}

  If we fix:
  \begin{enumerate}
  \item a vocabulary $\mathcal{V}$;
  \item a model $\mathcal{M}$ of that vocabulary;
  \item an assignment $v$ of elements of $U$ to free variables of $P$.
  \end{enumerate}
  then we can give a truth value $\sem{P}({\mathcal{M}},v)$ to $P$.
\end{frame}

\begin{frame}
  {Interpreting Formulas}

  Relations:
  \begin{displaymath}
    \begin{array}{lcl}
      \sem{R(x_1, \dots, x_n)}(\mathcal{M},v) &=& \true \quad \mathrm{if}\quad (v(x_1), \dots, v(x_n)) \in \mathrm{R} \\
                                              &=& \false \quad \textrm{otherwise} \\
      \\
      \sem{x = y}(\mathcal{M},v)              &=& \true \quad \textrm{if}\quad v(x) = v(y) \\
                                              &=& \false \quad \textrm{otherwise}
    \end{array}
  \end{displaymath}
  where $R$ is one of the relations in $\mathcal{M}$.
\end{frame}

\begin{frame}
  {Interpreting Formulas (Example)}

  With the cities model $\mathcal{M}$:

  \bigskip

  \begin{displaymath}
    \sem{\mathrm{within}(x,y)}(\mathcal{M}, [x\mapsto \mathsf{edinburgh}, y \mapsto \mathsf{scotland}]) = \true
  \end{displaymath}

  \bigskip

  \begin{displaymath}
    \sem{\mathrm{within}(x,y)}(\mathcal{M}, [x\mapsto \mathsf{edinburgh}, y \mapsto \mathsf{england}]) = \false
  \end{displaymath}
\end{frame}

\begin{frame}
  {Interpreting Formulas}

  Quantifiers:
  \begin{displaymath}
    \begin{array}{lcl}
      \sem{\forall x. P}(\mathcal{M},v) & = & \true \quad\textrm{if for all }a \in U,~\sem{P}(\mathcal{M},v[x \mapsto a]) = \true \\
      & = & \false \quad \textrm{otherwise} \\
      \sem{\exists x. P}(\mathcal{M},v) & = & \true \quad\textrm{if exists }a \in U,\textrm{ with }\sem{P}(\mathcal{M},v[x \mapsto a]) = \true \\
      & = & \false \quad \textrm{otherwise} \\
    \end{array}
  \end{displaymath}
  Notation $v[x \mapsto a]$ means the assignment that maps $x$ to $a$
  and any other variable to whatever $v$ mapped it to.
\end{frame}

\begin{frame}
  {Interpreting Formulas (Example)}

  \begin{displaymath}
    \sem{\forall x. \mathrm{city}(x)}(\mathcal{M},[]) = \false
  \end{displaymath}
  because all of the following would need to be $\true$:
  \begin{displaymath}
    \begin{array}{lcc}
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{aberdeen}]) &=& \true\\
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{edinburgh}]) &=& \true\\
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{glasgow}]) &=& \true\\
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{birmingham}]) &=& \true\\
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{scotland}]) &=& \false\\
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{england}]) &=& \false\\
    \end{array}
  \end{displaymath}
\end{frame}

\begin{frame}
  {Interpreting Formulas (Example)}

  \begin{displaymath}
    \sem{\exists x. \mathrm{city}(x)}(\mathcal{M},[]) = \true
  \end{displaymath}
  because only one of the following needs to be $\true$:
  \begin{displaymath}
    \begin{array}{lcc}
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{aberdeen}]) &=& \true\\
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{edinburgh}]) &=& \true\\
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{glasgow}]) &=& \true\\
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{birmingham}]) &=& \true\\
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{scotland}]) &=& \false\\
      \sem{\mathrm{city}(x)}(\mathcal{M},[x\mapsto\mathsf{england}]) &=& \false\\
    \end{array}
  \end{displaymath}
\end{frame}

\begin{frame}
  {Interpreting Formulas}

  Propositional Connectives:
  \begin{displaymath}
    \begin{array}{lcl}
      \sem{P \land Q}(\mathcal{M},v) &=& \sem{P}(\mathcal{M},v) \land \sem{Q}(\mathcal{M},v)\\
      \sem{P \lor Q}(\mathcal{M},v) &=& \sem{P}(\mathcal{M},v) \lor \sem{Q}(\mathcal{M},v)\\
      \sem{P \to Q}(\mathcal{M},v) &=& \sem{P}(\mathcal{M},v) \to \sem{Q}(\mathcal{M},v)\\
      \sem{\lnot P}(\mathcal{M},v) &=& \lnot \sem{P}(\mathcal{M},v)  \\
    \end{array}
  \end{displaymath}
\end{frame}

\begin{frame}
  {Interpreting Formulas (Example)}

  \begin{displaymath}
    \sem{\mathrm{city}(x) \land \mathrm{within}(x,y)}(\mathcal{M},[x\mapsto\mathsf{edinburgh},y\mapsto\mathsf{scotland}]) = \true
  \end{displaymath}
  and
  \begin{displaymath}
    \sem{\mathrm{city}(x) \land \mathrm{within}(x,y)}(\mathcal{M},[x\mapsto\mathsf{edinburgh},y\mapsto\mathsf{birmingham}]) = \false
  \end{displaymath}
  and
  \begin{displaymath}
    \sem{\mathrm{city}(x) \lor \mathrm{within}(x,y)}(\mathcal{M},[x\mapsto\mathsf{edinburgh},y\mapsto\mathsf{birmingham}]) = \true
  \end{displaymath}
\end{frame}

\begin{frame}
  {Some notation}

  We write
  \begin{displaymath}
    \mathcal{M} \models P
  \end{displaymath}
  when
  \begin{displaymath}
    \sem{P}(\mathcal{M}, []) = \true
  \end{displaymath}
  meaning that \emph{$\mathcal{M}$ is a model of $P$}.

  \pause
  \bigskip

  We write $\mathcal{M} \not\models P$ if this is not the case.
\end{frame}

\begin{frame}
  {Examples}

  If $\mathcal{M}$ is the cities model, then
  \begin{displaymath}
    \mathcal{M} \models \exists x. \mathrm{city}(x)  \qquad \textrm{\textcolor{black!60}{(there exists a city)}}
  \end{displaymath}


  \begin{displaymath}
    \mathcal{M} \not\models \forall x. \mathrm{city}(x)\qquad \textrm{\textcolor{black!60}{(not everything is a city)}}
  \end{displaymath}


  \begin{displaymath}
    \mathcal{M} \models \forall x. \mathrm{city}(x) \to (\exists y. \mathrm{within}(x,y))
  \end{displaymath}
  \hspace{6cm} \textcolor{black!60}{(every city is within something)}
\end{frame}

\begin{frame}
  {Entailment}

  Relative to a model $\mathcal{M}$:
  \begin{displaymath}
    \mathcal{M}; P_1, \dots, P_n \models Q
  \end{displaymath}
  exactly when:
  \begin{center}
    if all $\sem{P_i}(\mathcal{M},[]) = \true$, then $\sem{Q}(\mathcal{M},[]) = \true$.
  \end{center}

  \bigskip

  \textcolor{black!60}{If all the assumptions are true, then the conclusion must be true}
\end{frame}

\begin{frame}
  {Entailment}

  \begin{displaymath}
    P_1, \dots, P_n \models Q
  \end{displaymath}
  exactly when \emph{for all} $\mathcal{M}$, we have $\mathcal{M};P_1,\dots,P_n \models Q$.

  \bigskip

  Checking this is infeasible (at least naively): there are infinitely
  many models, and the models themselves may be infinite.

  \bigskip

  Which is one reason to use proof.
\end{frame}

\begin{frame}
  {Provability and Soundness}

  Recall that
  \begin{displaymath}
    P_1, \cdots, P_n \vdash Q
  \end{displaymath}
  means that $Q$ is provable from the assumptions $P_1, \cdots,
  P_n$.

  \bigskip
  \pause

  The proof system we have used so far is \emph{sound}:
  \begin{displaymath}
    P_1, \cdots, P_n \vdash Q\qquad \textrm{implies} \qquad P_1, \cdots, P_n \models Q
  \end{displaymath}
  \begin{itemize}
  \item If it is provable, then it is true in all models!
  \item Using proof means that we do not need to check infinitely many
    models, some of which may be infinite themselves.
  \end{itemize}
\end{frame}

\begin{frame}
  {Completeness}

  If we add excluded middle, then the proof system is also
  \emph{complete}:
  \begin{displaymath}
    P_1, \cdots, P_n \models Q\qquad \textrm{implies} \qquad P_1, \cdots, P_n \vdash Q
  \end{displaymath}
  \emph{every true entailment has a proof}
  \pause
  \begin{itemize}
  \item This is a remarkable and non-trivial fact!
  \item First proved by Kurt G{\"o}del: ``G{\"o}del's Completeness Theorem''
  \item It also holds if we have infinitely many assumptions
    $P_1, \cdots$, which means (because a proof can only use finitely
    many assumptions) that an entailment only depends on finitely many
    assumptions: Predicate logic is ``compact''.
  \end{itemize}

\end{frame}

\begin{frame}
  {Summary}

  We have defined what it means for a Predicate Logic $P$ formula to
  be true in some model $\mathcal{M}$, and entailment in all models.

  \begin{itemize}
  \item Just as with Propositional Logic, this is done by breaking
    down the formula into its constituent parts
  \item Must ensure that all free variables have an interpretation.
  \item When a formula is true in some model, we write $\mathcal{M} \models P$.
  \item Entailment ($P_1, ..., P_n \models Q$) is defined with respect to all models.
  \item Our proof system is sound and (with excluded middle) complete
    for this definition of entailment.
  \end{itemize}
\end{frame}

\weeksection{Using Models}

\begin{frame}
  {Using Models}

  Some of the things we can do with models:
  \begin{enumerate}
  \item Fix $\mathcal{M}$. Does $\mathcal{M} \models P$? \\
    \textcolor{black!60}{\emph{Model checking}}

  \item Fix $\mathcal{M}$. For what $P$ does $\mathcal{M} \models P$? \\
    \textcolor{black!60}{What is true about \emph{this} situation?} \\

  \item Fix $\mathcal{M}$. For what $a_1, \cdots, a_n$ does
    $\mathcal{M} \models P[a_1, \cdots, a_n]$? \\
    \textcolor{black!60}{Database queries}

  \item Fix formulas $P_1, ..., P_n$. Is there a model for them? \\
    \textcolor{black!60}{Generating {\it worlds} or {\it counterexamples}}

  \end{enumerate}
\end{frame}

\begin{frame}
  {Using Models: Model Checking}

  Given a model $\mathcal{M}$, computing $\mathcal{M} \models P$ works
  by breaking down the structure of $P$. For example:
  \begin{displaymath}
    \begin{array}{cl}
      & \mathrm{Cities} \models \exists x. \mathrm{city}(x) \land \mathrm{country}(x) \\
      = & \sem{\exists x. \mathrm{city}(x) \land \mathrm{country}(x)} (\mathcal{M}, [~]) \\
      = & \textrm{some}~a. \sem{\mathrm{city}(x) \land \mathrm{country}(x)}(\mathcal{M}, [x \mapsto a]) \\
      = & \textrm{some}~a. \sem{\mathrm{city}(x)}(\mathcal{M}, [x \mapsto a])~\textrm{and}~\sem{\mathrm{country}(x)}(\mathcal{M}, [x \mapsto a]) \\
      = & \textrm{some}~a. a \in \mathrm{city}~\textrm{and}~a \in \mathrm{country} \\
      = & \false \qquad \textrm{\textcolor{black!60}{(because no such $a$ exists, by checking them all)}}
    \end{array}
  \end{displaymath}
\end{frame}

\begin{frame}
  {Using Models: Database Queries}

  The \emph{Relational Model} is a system for organising data.
  \begin{itemize}
  \item Proposed by Edgar F. Codd in 1969.
  \item Implemented in PostgreSQL, MySQL, SQLite\footnote{there are
      \emph{at least} $\approx 1000$ SQLite DBs in this room.}, MS SQL
    Server, Oracle, IBM DB2, ...
  \item Typically using the Structured Query Language (SQL)
  \item Built on a logical foundation:
    \begin{enumerate}
    \item Vocabulary $\approx$ schema
    \item Predicates $\approx$ (finite) tables
    \item Formulas $\approx$ queries
    \item Models $\approx$ databases (collections of tables)
    \end{enumerate}
  \end{itemize}
\end{frame}

\begin{frame}
  {Using Models: Database Queries}

  An SQL query:
  \begin{displaymath}
    \begin{array}{l}
      \texttt{SELECT}~\texttt{City.X}~\texttt{FROM}~\texttt{City, Within} \\
      \texttt{WHERE}~\texttt{City.X = Within.X AND Within.Y = "scotland"}
    \end{array}
  \end{displaymath}

  \pause

  A formula, with free variable $x$:
  \begin{displaymath}
    \mathrm{city}(x) \land \mathrm{within}(x,\mathsf{scotland})
  \end{displaymath}
  The collection of $x$s that make this formula true in the model is
  the result of the query\footnote{terms and conditions apply}. The second half of CS209 introduces SQL.
\end{frame}

\begin{frame}
  {Models for Formulas}

  Given a collection of formulas $P_1, \cdots, P_n$, it is sometimes
  useful to generate a model $\mathcal{M}$ for them.
  \begin{enumerate}
  \item Sometimes it is easier to think about concrete examples
  \item Models can be used as counterexamples \textcolor{black!60}{\emph{see later...}}
  \item Can be used to generate interesting things \textcolor{black!60}{\emph{``Generative AI''}}
  \end{enumerate}
\end{frame}

\begin{frame}
  {Models for Formulas}

  With the following formulas:
  \begin{enumerate}
  \item $\exists x. \exists y. \mathrm{city}(x) \land \mathrm{city}(y) \land x \not= y$ \\
    \only<2->{\textcolor{black!60}{there exist at least two cities}} ~\\
  \item $\forall x. \mathrm{city}(x) \to (\exists y. \mathrm{country}(y) \land \mathrm{within}(x,y))$ \\
    \only<3->{\textcolor{black!60}{every city is in a country}} ~\\
  \item $\forall x. \lnot (\mathrm{city}(x) \land \mathrm{country}(x))$ \\
    \only<4->{\textcolor{black!60}{nothing is both a city and a country}} ~\\
  \end{enumerate}
\end{frame}

\begin{frame}
  {Models for Formulas}

  First attempt at a model (start minimal):
  \begin{displaymath}
    \begin{array}{lcl}
      \mathit{universe} &=& \{ \} \\
      \mathit{city} &=& \{ \} \\
      \mathit{country} &=& \{ \} \\
      \mathit{within} &=& \{ \} \\
    \end{array}
  \end{displaymath}

  \pause

  Does not satisfy $\exists x. \exists y. \mathrm{city}(x) \land \mathrm{city}(y) \land x \not= y$ \\
  \textcolor{black!60}{Need at least two cities!}
\end{frame}

\begin{frame}
  {Models for Formulas}

  Second attempt at a model (the names are arbitrary!):
  \begin{displaymath}
    \begin{array}{lcl}
      \mathit{universe} &=& \{ \mathsf{plockton}, \mathsf{auchtermuchty} \} \\
      \mathit{city} &=& \{ \mathsf{plockton}, \mathsf{auchtermuchty} \} \\
      \mathit{country} &=& \{ \} \\
      \mathit{within} &=& \{ \} \\
    \end{array}
  \end{displaymath}

  \pause

  Satisfies $\exists x. \exists y. \mathrm{city}(x) \land \mathrm{city}(y) \land x \not= y$ \\
  Does not satisfy $\forall x. \mathrm{city}(x) \to (\exists y. \mathrm{country}(y) \land \mathrm{within}(x,y))$ \\
  \textcolor{black!60}{Every city needs a country!}
\end{frame}

\begin{frame}
  {Models for Formulas}

  Third attempt at a model:
  \begin{displaymath}
    \begin{array}{lcl}
      \mathit{universe} &=& \{ \mathsf{plockton}, \mathsf{auchtermuchty} \} \\
      \mathit{city} &=& \{ \mathsf{plockton}, \mathsf{auchtermuchty} \} \\
      \mathit{country} &=& \{ \mathsf{plockton} \} \\
      \mathit{within} &=& \{ (\mathsf{auchtermuchty}, \mathsf{plockton}) \} \\
    \end{array}
  \end{displaymath}

  \pause

  Satisfies $\exists x. \exists y. \mathrm{city}(x) \land \mathrm{city}(y) \land x \not= y$ \\
  Does not satisfy $\forall x. \mathrm{city}(x) \to (\exists y. \mathrm{country}(y) \land \mathrm{within}(x,y))$ \\
  \textcolor{black!60}{$\mathsf{plockton}$ needs to be somewhere!}
\end{frame}

\begin{frame}
  {Models for Formulas}

  Fourth attempt at a model:
  \begin{displaymath}
    \begin{array}{lcl}
      \mathit{universe} &=& \{ \mathsf{plockton}, \mathsf{auchtermuchty} \} \\
      \mathit{city} &=& \{ \mathsf{plockton}, \mathsf{auchtermuchty} \} \\
      \mathit{country} &=& \{ \mathsf{plockton} \} \\
      \mathit{within} &=& \{ (\mathsf{auchtermuchty}, \mathsf{plockton}), (\mathsf{plockton}, \mathsf{plockton}) \} \\
    \end{array}
  \end{displaymath}

  \pause

  Satisfies $\exists x. \exists y. \mathrm{city}(x) \land \mathrm{city}(y) \land x \not= y$ \\
  Satisfies $\forall x. \mathrm{city}(x) \to (\exists y. \mathrm{country}(y) \land \mathrm{within}(x,y))$ \\
  Does not satisfy $\forall x. \lnot (\mathrm{city}(x) \land \mathrm{country}(x))$ \\
  \textcolor{black!60}{Nothing can be a city and a country!}
\end{frame}

\begin{frame}
  {Models for Formulas}

  Fifth attempt at a model:
  \begin{displaymath}
    \begin{array}{lcl}
      \mathit{universe} &=& \{ \mathsf{plockton}, \mathsf{auchtermuchty}, \mathsf{scotland} \} \\
      \mathit{city} &=& \{ \mathsf{plockton}, \mathsf{auchtermuchty} \} \\
      \mathit{country} &=& \{ \mathsf{scotland} \} \\
      \mathit{within} &=& \{
                          \begin{array}[t]{@{}l}
                            (\mathsf{auchtermuchty}, \mathsf{plockton}), (\mathsf{plockton}, \mathsf{plockton}), \\
                            (\mathsf{auchtermuchty}, \mathsf{scotland}), (\mathsf{plockton}, \mathsf{scotland})\}
                          \end{array}     \\
    \end{array}
  \end{displaymath}

  \pause

  Satisfies $\exists x. \exists y. \mathrm{city}(x) \land \mathrm{city}(y) \land x \not= y$ \\
  Satisfies $\forall x. \mathrm{city}(x) \to (\exists y. \mathrm{country}(y) \land \mathrm{within}(x,y))$ \\
  Satisfies $\forall x. \lnot (\mathrm{city}(x) \land \mathrm{country}(x))$
\end{frame}

\begin{frame}
  {Models for Formulas}

  Sixth attempt at a model:
  \begin{displaymath}
    \begin{array}{lcl}
      \mathit{universe} &=& \{ \mathsf{plockton}, \mathsf{auchtermuchty} \} \\
      \mathit{city} &=& \{ \mathsf{plockton}, \mathsf{auchtermuchty} \} \\
      \mathit{country} &=& \{ \mathsf{scotland} \} \\
      \mathit{within} &=& \{ (\mathsf{auchtermuchty}, \mathsf{scotland}), (\mathsf{plockton}, \mathsf{scotland})\}
    \end{array}
  \end{displaymath}

  \pause

  Satisfies $\exists x. \exists y. \mathrm{city}(x) \land \mathrm{city}(y) \land x \not= y$ \\
  Satisfies $\forall x. \mathrm{city}(x) \to (\exists y. \mathrm{country}(y) \land \mathrm{within}(x,y))$ \\
  Satisfies $\forall x. \lnot (\mathrm{city}(x) \land \mathrm{country}(x))$ \\
  \textcolor{black!60}{and doesn't have any extra stuff}
\end{frame}

\begin{frame}
  {Models for Formulas}

  General strategy for formulas $P_1, ..., P_n$:
  \begin{enumerate}
  \item See what is forced to exist without conditions \\
    \textcolor{black!60}{(e.g., at least two cities)}
  \item See what is then forced to exist by these things existing \\
    \textcolor{black!60}{(e.g., every city needs a country)}
  \item Disjointness axioms force non-overlap and more existence \\
    \textcolor{black!60}{(e.g., not a city and a country)}
  \item Try to keep the model minimal \\
    \textcolor{black!60}{(without the first formula, the empty model would work!)}
  \end{enumerate}
\end{frame}


\begin{frame}
  {Proof and Counterexamples}

  Models can be used to show some formulas are \emph{unprovable}. \\
  \qquad \textcolor{black!60}{Not the same as \emph{failing to prove it!}}

  \bigskip
  \pause

  To show that there is no proof of $P_1, ..., P_n \vdash Q$:
  \begin{enumerate}
  \item Find a model $\mathcal{M}_c$ that makes all of
    $\mathcal{M}_c \models P_1, \cdots, P_n$, but $\mathcal{M}_c \not\models Q$.
    \textcolor{black!60}{($\mathcal{M}_c$ is the \emph{countermodel})}
  \item \emph{If} we could prove $P_1, ..., P_n \vdash Q$ then (by soundness):
    \begin{itemize}
    \item every model $\mathcal{M}$ such that $\mathcal{M} \models P_1, ..., P_n$, then $\mathcal{M} \models Q$
    \end{itemize}
  \item But we have $\mathcal{M}_c$ that supports $P_1, ..., P_n$ and {\bf not} $Q$
  \item So $P_1, ..., P_n \vdash Q$ is {\bf not} provable.
  \end{enumerate}
\end{frame}

\begin{frame}
  {Example}

  It is not possible to prove
  \begin{displaymath}
    \lnot (\exists x. \mathrm{country}(x))
  \end{displaymath}
  from the assumptions:
  \begin{enumerate}
  \item $\exists x. \exists y. \mathrm{city}(x) \land \mathrm{city}(y) \land x \not= y$
  \item $\forall x. \mathrm{city}(x) \to (\exists y. \mathrm{country}(y) \land \mathrm{within}(x,y))$
  \item $\forall x. \lnot (\mathrm{city}(x) \land \mathrm{country}(x))$
  \end{enumerate}

  \pause
  \bigskip

  The model above satisfies all these, but not $\lnot (\exists x. \mathrm{country}(x))$.

  \bigskip

  Therefore, there is no proof of this formula from these assumptions.

\end{frame}

\begin{frame}
  {Summary}

  Several useful questions can be asked using models:
  \begin{enumerate}
  \item Model checking: does $\mathcal{M} \models P$?
  \item Model checking for all values: for what $x$ does $\mathcal{M} \models P[x]$? \\
    \textcolor{black!60}{database queries!}
  \item Model generation for formulas $P_1, ..., P_n$ \\
    \textcolor{black!60}{can be used to show unprovable things}
  \end{enumerate}

  \bigskip

  With sufficiently adapted ideas of ``formula'' and ``model'', many
  questions can be recast in terms of logic and implemented on a computer.

\end{frame}

\end{document}
